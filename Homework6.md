# 作业6

## 1. 预取I

假如你是一位架构师，正在为你的机器设计预取引擎。你先在机器上使用跨度预取器执行了 A 和 B 两个应用。 

应用 A:  

```C
uint8_t a[1000];  
sum = 0;  
for (i = 0; i < 1000; i += 4)  {  
	sum += a[i];  
}
```

应用 B: 

```c
uint8_t a[1000];  
sum = 0;  
for (i = 1; i < 1000; i *= 4)  {  
	sum += a[i];  
}
```

i 和 sum 在寄存器中，数组 a 在内存中，一个 cache 块大小为 4 个字节。

- 使用跨度预取器，应用 A 和 B 的预取精度和覆盖率分别是多少？这个跨度预取器检测两次连续访存的跨度，从当前访问的 cache 块按照这个跨度预取下一个 cache 块。

  - 应用A

    在第一次跨度之后，后面每次预取都是正确的。一共要访存250次，每次访问都不在同一个cache块中。

    预取精确度：第二次无法按跨度预取，因此精确度248/249

    预取覆盖率：前两次无法预取，248/250

  - 应用B

    总共访存5次，全部预取错误。

    精确度：0

    覆盖率：0

- 请分别为应用 A 和 B 建议能获得更好的精度和覆盖率的预取器

  - 应用A：Next-line预取器
  - 应用B：基于执行的预取器

## 2. 预取II

你跟你的同学一起设计一个预取器，这台机器使用单核、 L1 和 L2 cache 以及 DRAM 内存。我们需要分析不同的预取器和可能的tradeoff。 在本题中，我们要计算预取器在达到稳定状态后的预取精度、覆盖率和带宽开销，所以，所有计算都 不包括最开始的 6 次请求，这 6 次请求作为预取器的训练集。

- 你首先设计一个跨度预取器，观察最后三次 cache 块请求，如果最后三次请求的跨度是常数，预取器将会使用这一跨度预取下一个 cache 块。 你执行了一个应用，它具有如下的访存模式 (这些是 cache 块地址):  A，A+1，A+2，A+7，A+8，A+9，A+14，A+15，A+16，A+21，A+22，A+23，A+28，A+29，A+30...  假设这个模式持续了很长时间。 计算你的跨度预取器对于这个应用的精度和覆盖率

  每次预取器发现最后三个请求跨度是常数时，这个常数间隔均为1，导致预取出间隔为1的下一个cache块。

  但是访存模式表明，每连续取三块以后，都会进行间隔跳跃，导致预取块并没有命中。

  因此，预取器精度为0，覆盖率为0。

- 你的同学设计了一个新的预取器，当有一个 cache 块访问时，预取紧接着的 N 个 cache 块

  -  如果用他的预取器执行你刚刚执行过的应用，预取覆盖率和精度分别是 66.67%和 50%，N 是多少? 

    每三个块中有两个被覆盖，说明N=2。验证表明N=2时精度为50%。

  -  假如我们将带宽开销定义为：有预取器时所有 cache 块的请求数/没有预取器时所有 cache 块的请求数，那么你同学的预取器在执行刚才那个应用时的带宽开销是多少？

    N=2时，每三次访存，有预取器会总共请求i、i+1、…、i+4这5块；无预取器会请求3块。

    所以带宽开销为5/3。

  - 你的同学希望改进他的预取器对于刚才那个应用的覆盖率，他可以容忍带宽开销最多两倍。请问他能做到吗？为什么可以/不可以？

    不可以，在带宽开销为2时，N最大为3，但是覆盖率相比N=2没有提升。

  - 对于上面的应用，如果想获得 100%的覆盖率，N 最小得是多少？这个时候的带宽开销是多少?

    N最小为5。

    此时带宽开销为7/3。

## 3. Cache一致性

- MESI cache 一致性协议比 MSI 协议好在哪里?

  MESI协议相比MSI协议新增加了一种状态，即其存储了某一块cache仅仅被一个进程使用的E状态。在E状态下，进程对于该cache的操作并不会使得附加程序扫描整个cache中其他块的内容以寻找共享块，进而减小了开销。

- 你想要利用 MESI 置无效协议设计一个基于目录的 cache 一致性系统，在特定的工作负载下，系统表现得很糟糕，经过仔细的分析，你发现有 4 个节点持续的发出对某个 cache 块的置无效请求，这是什么情况?

  4个节点轮流对同一个cache进行先读后写操作。

- 如何解决这一问题?

  将4个节点操作的同一个cache通过目录映射到同一块上共用标记。

## 4. 一致性协议

假设有一个多处理器系统，系统有 512 个处理器，每个处理器有 1MB 的私有写回方式的 cache，每个 cache 块 64 字节，主存大小为 1GB。

- 如果我们基于 MESI cache 一致性协议设计了监听总线，需要多少状态位才能够实现这个一致性协议?  这些状态位放在哪? 

  MESI需要对每个cache块用2bit存储状态。

  每个处理器有$1MB \div 64B = 2^{14}$个cache块，

  整个系统需要$2\times512\times2^{14}=2^{24}$个状态位。

  状态位存在每个处理器的私用存储中。

- 如果用基于目录的 cache 一致性协议替换，需要多少状态位? 这些状态位在哪? 

  首先，上一问中的cache标签占用的空间不变。

  增加对于目录的存储，针对每一个存储块：

  每个cache占一位，共512位，显示某一块是否在某一cache中；

  增加一个独占位，指示是否该块由某一cache独占。

  因此每个存储块对应513位。

  共有$1GB \div 64B = 2^{24}$块；

  共需要$2^{24} \times 513$位。

  目录存储在主存中。

- 对于这个系统，你会选择哪一个协议? 为什么?

  选择监听总线，因为目录内容实在太庞大，查询起来也比较耗时。

## 5. 并行加速比

假如你是一家公司的程序猿，你被要求并行化一个老程序以使它能够在现代多核处理器上跑得更快

- 你并行化了这个程序，然后发现它对于单线程版本的加速比相比于处理器个数的增加而言相差很多。 你发现在每个核的数据 cache 中有大量的 cache 无效存在，什么样的程序行为导致了这种现象? (请用 10 个字左右简要说明) 

  存在大量数据由多个核并行访问。

- 你修改了程序以解决这个性能问题，然后你发现程序在每个并行计算之后的一个单个线程都会更新 一个全局状态，因此导致性能的下降。你的程序有 90%的工作是并行的(按照处理器个数 X 秒计算得 出)，另有10%的工作是串行的，并行部分是完美的并行。如果多核处理器核数无限，程序的最大加速比可以到多少? 

  n个核心时，加速比为$\frac{1}{10\% + 90\% \div n}$，当n趋近于无穷时，加速比为10。

- 如果要获得 4 倍的加速比，应该有多少处理器?

  n=6

- 为了使你改写的程序更高效，公司决定设计一款专门的异构处理器。这款处理器由一个大核(执行代码更快，但是占据的片上面积更大)和多个小核(执行代码更慢，但是消耗面积更小)共享处理器的片上空间。 你的程序并行部分的所有线程将只会在小核上执行；程序的串行部分将有一个线程执行在大核上。核的性能(执行速度)与它的面积的平方根成正比。 假设芯片面积有 16 个单元可用，一个小核至少占用 1 个单元，大核可以占用任意数量的单元。同时假设没有被大核使用的面积会被小核填满。

  -  如果想让你的程序获得可能的最快执行速度，大核需要多大? 

    设大核占用x面积，则有（16-x）个小核心。大核心加速比为$\sqrt{x}$，整体加速比为$\frac{1}{0.1 \div \sqrt{x} + 0.9 \div (16 - x)}$。

    x只能为整数。通过枚举可知x=4时，加速比最大。

  -  如果所有 16 个单元全部拿来用做小核，这个处理器就变成了同构的多核处理器，对于你的程序而言，它的加速比是多少? 假设串行部分跑在一个小核上，并行部分跑在所有 16 个小核上。

    加速比为$\frac{1}{0.1 + 0.9 \div 16}=6.4$

  -  在串行部分是 10%的情况下，使用异构多核(大小核)处理器是有意义的吗? 为什么是/不是? 

    有意义。x=4时，加速比为8，大于6.4。

- 现在你继续优化了你的程序，使得串行部分仅占 4%(剩下 96%是并行部分)。

  - 这个时候大核应该有多大(占多少单元)? 

    加速比为$\frac{1}{0.04 \div \sqrt{x} + 0.96 \div (16 - x)}$。

    枚举得到x=4。

  - 大核这么大的时候加速比是多少?

    x=4时加速比为10。

  - 假如此时我们采用 16 个小核的同构多核处理器，你的程序的加速比是多少(假设串行部分跑在一 个小核上，并行部分跑在所有 16 个小核上)? 

    加速比为10。

  - 在串行部分是 4%的情况下，使用异构多核(大小核)处理器还是有意义的吗? 为什么是/不是? 

    没有意义，加速比没有变化。

    

​	